h2#combine-observables Combine observables



+descr-method('combine', 'combine', 'Kefir.combine(obss, [fn])', 'obs.combine(otherObs, [fn])').
  Returns a stream.
  Combines two or more observables together. On each value from any of source
  observables (#[b obss] array) emits combined value, generated by #[b fn]
  function from latest values from each source observable. #[b Fn]
  is called with latest values as arguments.
  If no #[b fn] provided, it emits an array containing latest values.

p.
  It emits a value only when all source observables have emitted at least once.
  Ends when all source observables ends.

p.
  You can also combine two observables by calling #[tt a.combine(b, fn)] if you like.

pre(title='example').
  var foo = Kefir.emitter();
  var bar = Kefir.emitter();
  var sum = Kefir.combine([foo, bar], function(f, b) {
    return f + b;
  });
  foo.log('foo');
  bar.log('bar');
  sum.log();

  foo.emit(1);
  bar.emit(2);
  foo.emit(3);
  bar.end();
  foo.end();

pre(title='console output')
  :escapehtml
    > foo <value> 1
    > bar <value> 2
    > [combine] <value> 3
    > foo <value> 3
    > [combine] <value> 5
    > bar <end>
    > foo <end>
    > [combine] <end>

pre(title='events in time').
  foo:  --1-----3-----X
  bar:  -----2-----X

  sum:  -----3--5-----X
div


+descr-method('and', 'and', 'Kefir.and(obss)', 'obs.and(otherObs)').
  Combines #[b obss] observables using #[tt &amp;&amp;] (logical and) operator.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();
  var c = Kefir.emitter();
  var isAllTrue = Kefir.and([a, b, c]);
  isAllTrue.log();

  a.emit(true);
  b.emit(false);
  c.emit(true);
  b.emit(true);
  a.emit(false);

pre(title='console output')
  :escapehtml
    > [and] <value> false
    > [and] <value> true
    > [and] <value> false

pre(title='events in time').
  a:          --t-----------f--
  b:          -----f-----t-----
  c:          --------t--------

  isAllTrue:  --------f--t--f--
div

p.
  See also #[a(href="#not") not].


+descr-method('or', 'or', 'Kefir.or(obss)', 'obs.or(otherObs)').
  Combines #[b obss] observables using #[tt ||] (logical or) operator.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();
  var c = Kefir.emitter();
  var isAnyTrue = Kefir.or([a, b, c]);
  isAnyTrue.log();

  a.emit(true);
  b.emit(false);
  c.emit(true);
  b.emit(true);
  a.emit(false);

pre(title='console output')
  :escapehtml
    > [or] <value> true
    > [or] <value> true
    > [or] <value> true

pre(title='events in time').
  a:          --t-----------f--
  b:          -----f-----t-----
  c:          --------t--------

  isAnyTrue:  --------t--t--t--
div

p.
  See also #[a(href="#not") not].


+descr-method('sampled-by', 'sampledBy', 'Kefir.sampledBy(passiveObss, activeObss, [fn])', 'obs.sampledBy(otherObs, [fn])').
  Like <a href="#combine">combine</a>, but instead of one array of source
  observables it accepts two — #[b passiveObss] and #[b activeObss],
  then works just like #[b combine] except emits values only on values
  from #[b activeObss]. But in #[b fn]
  function you have values from both #[b passiveObss] and #[b activeObss].

p.
  If no #[b fn] provided emits an array of latest values, just like #[b combine].
  Actually #[b combine] is a #[b sampledBy] with empty array as #[b passiveObss],
  and all source observables as #[b activeObss].

p.
  Ends when all of #[b activeObss] ends.

pre(title='example').
  var a = Kefir.repeatedly(100, [0, 1, 2]);
  var b = Kefir.repeatedly(100, [0, 1, 2]).delay(20);
  var c = Kefir.sequentially(100, [0, 1, 2]).delay(40);
  var d = Kefir.sequentially(100, [0, 1, 2]).delay(60);
  var sum = Kefir.sampledBy([a, b], [c, d], function(_a, _b, _c, _d) {
    return _a + _b + _c + _d;
  });
  sum.log();

pre(title='console output')
  :escapehtml
    > [sampledBy] <value> 0
    > [sampledBy] <value> 3
    > [sampledBy] <value> 4
    > [sampledBy] <value> 7
    > [sampledBy] <value> 8
    > [sampledBy] <end>

pre(title='events in time').
  a:    ----------0---------1---------2---------0-----
  b:    ------------0---------1---------2---------0---
  c:    --------------0---------1---------2X
  d:    ----------------0---------1---------2X

  sum:  ----------------0-------3-4-------7-8X

p.
  As you can see on a graph, #[b sampledBy] emits only on events
  from #[b active sources], and only when it has at least one value from each source.
  Also it not waits for #[b passive sources] to end, only for active.

p.
  You can also sample one observable by another like this #[tt a.sampledBy(b, fn)],
  it is an equivalent of #[tt Kefir.sampledBy([a], [b], fn)].
  If you omit #[b fn], #[tt function(a, b) {return a}] will be used in
  #[tt a.sampledBy(b)].



+descr-method('zip', 'zip', 'Kefir.zip(sources, [combinator])', 'obs.zip(otherObs, [combinator])').
  Creates a stream with values from #[b sources]
  lined up with each other. For example if you have two sources with values
  #[tt [1, 2, 3]] and #[tt [4, 5, 6, 7]], the result stream will emit
  #[tt [1, 4]], #[tt [2, 5]], and #[tt [3, 6]].
  The result stream will emit next value only when it has at least one value
  from each of sources.

p.
  You can also provide a #[b combinator] function, in this case instead
  of emitting array of values, they will be passed to #[b combinator] as arguments,
  and returned value will be emitted (same as in #[a(href="#combine") combine],
  #[a(href="#sampled-by") sampledBy], etc.)

p.
  Also in #[b zip] you can pass ordinary arrays along with observables
  in #[b sources], e.g. #[tt Kefir.zip([obs,&nbsp;[1,&nbsp;2,&nbsp;3]],&nbsp;fn)].
  In other words, #[b sources] is an array of observables and arrays,
  or only observables of course.

p.
  The result stream ends when all sources end.

pre(title='example').
  var a = Kefir.sequentially(100, [0, 1, 2, 3]);
  var b = Kefir.sequentially(160, [4, 5, 6]);
  var c = Kefir.sequentially(100, [8, 9]).delay(260).toProperty(7);
  var result = Kefir.zip([a, b, c]);
  result.log();

pre(title='console output')
  :escapehtml
    > [zip] <value> [0, 4, 7]
    > [zip] <value> [1, 5, 8]
    > [zip] <value> [2, 6, 9]
    > [zip] <end>

pre(title='events in time').
  a:    ----0----1----2----3X
  b:    -------4-------5-------6X
  c:   7-----------------8----9X

  abc:  -------•---------•-----•X
         [0,4,7]   [1,5,8]     [2,6,9]
div


+descr-method('merge', 'merge', 'Kefir.merge(obss)', 'obs.merge(otherObs)').
  Merges several #[b obss] observables into single stream,
  i.e. simply repeats values from each source observable.
  Ends when all #[b obss] observables ends.

p.
  You can also merge two observables by calling #[tt a.merge(b)], if you like.

pre(title='example').
  var a = Kefir.sequentially(100, [0, 1, 2]);
  var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
  var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
  var abc = Kefir.merge([a, b, c]);
  abc.log();

pre(title='console output')
  :escapehtml
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <end>

pre(title='events in time').
  a:    ----------0---------1---------2X
  b:    ------------0---------1---------2X
  c:    --------------0---------1---------2X

  abc:  ----------0-0-0-----1-1-1-----2-2-2X
div


+descr-method('concat', 'concat', 'Kefir.concat(obss)', 'obs.concat(otherObs)').
  Concatenates several #[b obss] observables into one stream. Like <a href="#merge">merge</a>,
  but it starts emitting values from next source only after previous source ends,
  ignoring any values from next sources before that.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();
  var c = Kefir.emitter();

  var abc = Kefir.concat([a, b, c]);
  abc.log();

  a.emit(0).emit(1);
  b.emit(0);
  a.emit(2).end();
  c.emit(0);
  b.emit(1);
  c.emit(1);
  b.emit(2).end();
  c.emit(2).end();

pre(title='console output')
  :escapehtml
    > [concat] <value> 0
    > [concat] <value> 1
    > [concat] <value> 2
    > [concat] <value> 1
    > [concat] <value> 2
    > [concat] <value> 2
    > [concat] <end>

pre(title='events in time').
  a:    ---0---1---2X
  b:    ---------0-----1---2X
  c:    -------------0---1---2X

  abc:  ---0---1---2---1---2-2X
div



+descr-method('pool', 'pool', 'Kefir.pool()').
  #[b Pool] is like <a href="#merge">merge</a> to which you
  can dynamically add and remove sources.
  When you create a new #[b pool] it has no sources, then you can
  add observables to it using #[b plug] method,
  and remove using #[b unplug]. #[b Pool] never ends.

pre(title='example').
  var a = Kefir.emitter();
  var b = Kefir.emitter();

  var pool = Kefir.pool();
  pool.log();

  a.emit(1);
  b.emit(1);
  pool.plug(a);
  a.emit(2);
  b.emit(2);
  pool.plug(b);
  a.emit(3);
  b.emit(3);
  pool.unplug(a);
  a.emit(4);
  b.emit(4);
  a.end();
  b.end();

pre(title='console output')
  :escapehtml
    > [pool] <value> 2
    > [pool] <value> 3
    > [pool] <value> 3
    > [pool] <value> 4

pre(title='events in time').
  a:       ---1-----2-----3----4-----X
  b:       ----1------2------3----4---X

  plug:    ------a------b------------------
  unplug:  -------------------a------------

  pool:    ---------2-----3--3----4--------

p.
  In this graph #[b plug] and #[b unplug] shown just to illustrate
  moments when we plug and unplug sources, don't be confused that
  there is some #[b plug] or #[b unplug] streams somewhere.



+descr-method('bus', 'bus', 'Kefir.bus()').
  #[b Bus] is a pool with <a href="#emitter">emitter</a> methods.
  You can emit values from it directly. It is the best choice to expose
  an input from a module, so module users could easily send events to your
  module directly or by plugging an observable.

pre(title='example').
  var bus = Kefir.bus();
  var emitter = Kefir.emitter();
  bus.log();

  bus.plug(emitter);
  bus.emit(1);
  emitter.emit(2);
  bus.end();

pre(title='console output')
  :escapehtml
    > [bus] <value> 1
    > [bus] <value> 2
    > [bus] <end>
div




+descr-method('flat-map', 'flatMap', 'obs.flatMap([transform])').
  Works similar to <a href="#flatten">flatten</a>,
  but instead of array handles observables. Like in #[b flatten] you can
  either provide a #[b transform] function which will return observables,
  or you can use source #[b obs] observable that already emits observables.

p.
  #[b flatMap] ends when #[b obs] and all spawned observables ends.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMap(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X
div




+descr-method('flat-map-latest', 'flatMapLatest', 'obs.flatMapLatest([fn])').
  Like #[b flatMap], but repeats events only from the latest added observable.
  I.e. it switching from one observable to another.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapLatest(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1-----2---2-----3---3---3---3X
div



+descr-method('flat-map-first', 'flatMapFirst', 'obs.flatMapFirst([fn])').
  Like #[b flatMap], but adds new observable only if previous one ended,
  in other case it just ignoring new observable.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapFirst(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1---1-------3---3---3---3X
div



+descr-method('flat-map-concat', 'flatMapConcat', 'obs.flatMapConcat([fn])').
  Like #[a(href='flat-map-first') flatMapFirst], but instead of ignoring new observables
  (if previous one still alive), it adds them to the queue.
  Then, when current source ends, it takes the oldest observable from the queue,
  and switches to it.

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapConcat(function(x) {
    return Kefir.interval(40, x).take(4);
  });
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                             ---2---2---2---2X
  spawned 3:                                             ---3---3---3---3X

  result:      -------------1---1---1---1---2---2---2---2---3---3---3---3X
div



+descr-method('flat-map-with-concurrency-limit', 'flatMapConcurLimit', 'obs.flatMapConcurLimit([fn], limit)').
  Like #[a(href='flat-map-concat') flatMapConcat], but with configurable number of concurent sources,
  in other words #[b flatMapConcat] is #[tt flatMapConcurLimit(fn, 1)].

pre(title='example').
  var source = Kefir.sequentially(100, [1, 2, 3]);
  var result = source.flatMapConcurLimit(function(x) {
    return Kefir.interval(40, x).take(6);
  }, 2);
  result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <end>

pre(title='events in time').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1---1---1X
  spawned 2:                       ---2---2---2---2---2---2X
  spawned 3:                                     ---3---3---3---3---3---3X

  result:      -------------1---1---1-2-1-2-1-2-1-2-3-2-3-2-3---3---3---3X
div
